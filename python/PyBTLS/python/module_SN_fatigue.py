import math
import rainflow
from PyBTLS.cpp import BTLS


class FatigueCalculation():
    def __init__(self):
        print("\t"+"Sim and analyse, or Read and analyse.")
    
    # Analyse all the sim outcomes
    # def sim_and_analyse(self, SN_file_name:str, SN_file_log:bool, section_class:list) -> list:
    #     btls = BTLS()
    #     btls.run()
    #     rainflow_result = btls.get_rainflow_result()
    #     # For SN file
    #     SN_curves, SN_number = self.read_SN_file(SN_file_name,SN_file_log)
    #     # Calculate the fatigue index
    #     fatigue_index = []
    #     for i in range(0,len(rainflow_result)):
    #         fatigue_index.append([])
    #         for j in range(0,len(rainflow_result[i])):
    #             fatigue_index[i].append([])
    #             load_effect = rainflow_result[i][j]
    #             fatigue_load_rainflow = []
    #             load_value = [float(k) for k in list(load_effect)]
    #             load_cycle_num = list(load_effect.values())
    #             for k in range(1,len(load_effect)):  # The first value could be zero, causing log10() error. 
    #                 fatigue_load_rainflow.append([self.__to_common_logarithm(load_value[k]),load_cycle_num[k]])
    #             SN_curves_in_use = self.__select_SN_curve(SN_curves[i][j],section_class[i][j],SN_number[i][j])
    #             fatigue_index[i][j].append(self.__miners_rule(fatigue_load_rainflow,SN_curves_in_use,section_class[i][j]))
    #     return fatigue_index

    # For one bridge per analysis
    def read_and_analyse(self, fatigue_file_name:str, SN_file_name:str, SN_file_log:bool, section_class:list, select_load_effect:list=[]) -> list:
        # For fatigue file
        fatigue_loads = self.read_fatigue_load_file(fatigue_file_name)
        self.load_to_stress()  # remember to modify it
        fatigue_loads = self.__select_load_effect(fatigue_loads,select_load_effect)
        fatigue_loads_rainflow = self.rainflow_algorithm(fatigue_loads)
        # convert load value to log
        for i in range(0,len(fatigue_loads_rainflow)):
            for j in range(1,len(fatigue_loads_rainflow[i])):  # The first value could be zero, causing log10() error. 
                fatigue_loads_rainflow[i][j][0] = self.__to_common_logarithm(fatigue_loads_rainflow[i][j][0])
        # For SN file
        SN_curves, SN_number = self.read_SN_file(SN_file_name,SN_file_log)
        if len(select_load_effect) != 0:
            SN_curves = [SN_curves[0][i-1] for i in select_load_effect]
            SN_number = [SN_number[0][i-1] for i in select_load_effect]
        else:
            SN_curves = SN_curves[0]
            SN_number = SN_number[0]
        # Calculate the fatigue index
        fatigue_index = []
        for i in range(0,len(fatigue_loads_rainflow)):
            fatigue_index.append([])
            SN_curves_in_use = self.__select_SN_curve(SN_curves[i],section_class[i],SN_number[i])
            fatigue_index[i].append(self.__miners_rule(fatigue_loads_rainflow[i],SN_curves_in_use,section_class[i]))
        return fatigue_index

    # To read fatigue data generated by BTLS
    def read_fatigue_load_file(self, file_name:str) -> list:
        fatigue_loads = []
        i = 0
        with open(file_name, "r") as file:
            for data in file.readlines():
                if i == 0:
                    i += 1
                    continue
                if i == 1:
                    i += 1
                    load_effects_num = len(data.split())-2
                    while len(fatigue_loads) < load_effects_num:
                        fatigue_loads.append([])
                for j in range(load_effects_num):
                    fatigue_loads[j].append(float(data.split()[j+2]))
        return fatigue_loads

    def __select_load_effect(self, fatigue_loads:list, select_load_effect:list=[]) -> list:
        if len(select_load_effect) == 0:
            return fatigue_loads
        if isinstance(select_load_effect,list):
            return_value = []
            for i in select_load_effect:
                return_value.append(fatigue_loads[i-1])
            return return_value
        else:
            raise ValueError("Type of select_load_effect needs to be int list!")

    # To convert from load to stress then input to rainflow
    def load_to_stress(self):
        pass

    # To apply the rainflow algorithm to stress
    def rainflow_algorithm(self, fatigue_loads:list, ndigits:int=1) -> list:
        if not isinstance(fatigue_loads[0],list):  # just run rainflow for one load effect's history [data]
            fatigue_loads_rainflow = rainflow.count_cycles(fatigue_loads,ndigits)
            for i in range(0,len(fatigue_loads_rainflow)):
                fatigue_loads_rainflow[i] = list(fatigue_loads_rainflow[i])
            return fatigue_loads_rainflow
        else:
            fatigue_loads_rainflow = []
            while len(fatigue_loads_rainflow) < len(fatigue_loads):
                fatigue_loads_rainflow.append([])
            for i in range(0,len(fatigue_loads_rainflow)):
                fatigue_loads_rainflow[i] = rainflow.count_cycles(fatigue_loads[i],ndigits)
                for j in range(0,len(fatigue_loads_rainflow[i])):
                    fatigue_loads_rainflow[i][j] = list(fatigue_loads_rainflow[i][j])
            return fatigue_loads_rainflow

    # To convert base number to logarithm
    def __to_common_logarithm(self, input_num:float) -> float:
        return math.log10(input_num)

    # To read user-defined SN curve file
    def read_SN_file(self, file_name, logarithm:bool) -> tuple:
        return_value = []
        SN_number = []
        if isinstance(file_name,str):  # Read and analyse
            file_name = [file_name]
        if isinstance(file_name,list):  # Sim and analyse
            for i in range(0,len(file_name)):
                return_value.append([])
                SN_number.append([])
                with open(file_name[i], "r") as file:
                    j = -1
                    for line in file.readlines():
                        data = [float(k) for k in line[:-1].split(",")]
                        if not logarithm:
                            data = [self.__to_common_logarithm(k) for k in data]
                        if len(data) == 1:
                            return_value[i].append([])
                            SN_number[i].append(0)
                            SN_number[i][j] = int(SN_number[i][j]/2)
                            j += 1
                        else:
                            return_value[i][j].append(data)
                            SN_number[i][j] += 1
            SN_number[i][j] = int(SN_number[i][j]/2)
            return return_value, SN_number
        else:
            raise ValueError("Type of file_name needs to be str or str list!")

    # To determine which interval the data drops in (The input list should be in descending order)
    def __interval_check(self, target_value, exist_intervals:list):
        if target_value in exist_intervals:
            return [exist_intervals.index(target_value)]
        else:
            res = len(exist_intervals)-1
            if target_value < exist_intervals[-1]:
                return [-1,-1]  # lower than the minimum value
            while res>=0 and target_value>=exist_intervals[res]:
                res -= 1
            return [res,res+1]

    # To determine which (two) curve(s) will be used, and section_class=1 is the greatest
    def __select_SN_curve(self, SN_curves:list, section_class:float, SN_number:int):
        target_value = SN_number-section_class
        exist_intervals = list(range(0,SN_number))
        exist_intervals.reverse()
        self.__SN_curve_selection = self.__interval_check(target_value,exist_intervals)
        if -1 in self.__SN_curve_selection:
            raise RuntimeError("The section class has exceeded the range of SN curves!")
        return SN_curves[2*self.__SN_curve_selection[0]:2*self.__SN_curve_selection[-1]+2]  # Note this +2 not +1 is because Python's "list[0:n+1] to get n+1 elements" grammer...
 
    # To determine which interval the stress drops in (The input list should be in descending order)
    def __SN_interval_check(self, target_value, exist_intervals):
        return_value = self.__interval_check(target_value,exist_intervals)
        if return_value.count(-1) == 2:
            print("Stress is not counted as its amplitude is less than the smallest SN curve point!")
        elif return_value.count(-1) == 1:
            raise RuntimeError("Stress amplitude is larger than the largest SN curve point!")
        return return_value

    # To calcualte the specific value within the interval based on linear interpolation
    def __SN_linear_interpolation(self, x_data:list, y_data:list, y_value:float) -> float:
        SN_interval_selection = self.__SN_interval_check(y_value,y_data)
        if SN_interval_selection.count(-1) == 2:
            return float('inf')
        if len(SN_interval_selection) == 1:
            x_value = (x_data[SN_interval_selection[0]]+x_data[SN_interval_selection[-1]])/2
            return x_value
        else:
            x_value = (y_value-y_data[SN_interval_selection[0]])/(y_data[SN_interval_selection[-1]]-y_data[SN_interval_selection[0]])*(x_data[SN_interval_selection[-1]]-x_data[SN_interval_selection[0]]) + x_data[SN_interval_selection[0]]
            return x_value

    # To use Miner's rule for fatigue_index
    def __miners_rule(self, fatigue_after_rainflow:list, SN_curves_in_use:list, section_class:float) -> float:
        fatigue_index = 0.0
        for fatigue_load in fatigue_after_rainflow:
            fatigue_life = []
            for SN_curve in [[SN_curves_in_use[0],SN_curves_in_use[1]],[SN_curves_in_use[-2],SN_curves_in_use[-1]]]:
                fatigue_life.append(self.__SN_linear_interpolation(SN_curve[0],SN_curve[1],fatigue_load[0]))
            if math.isinf(fatigue_life[0]) or math.isinf(fatigue_life[1]):
                fatigue_life = float('inf')
            elif fatigue_life[0] == fatigue_life[1]:
                fatigue_life = (fatigue_life[0]+fatigue_life[1])/2
            else:
                fatigue_life = fatigue_life[0]-(section_class-1-self.__SN_curve_selection[0])/(self.__SN_curve_selection[-1]-self.__SN_curve_selection[0])*(fatigue_life[0]-fatigue_life[1])
            fatigue_index += fatigue_load[1]/(10**fatigue_life)
        return fatigue_index
